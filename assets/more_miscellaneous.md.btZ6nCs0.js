import{_ as i,o as s,c as a,R as e}from"./chunks/framework.ekaVIUcx.js";const u=JSON.parse('{"title":"杂项","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"more/miscellaneous.md","filePath":"more/miscellaneous.md","lastUpdated":1701705890000}'),t={name:"more/miscellaneous.md"},l=e('<h1 id="杂项" tabindex="-1">杂项 <a class="header-anchor" href="#杂项" aria-label="Permalink to &quot;杂项&quot;">​</a></h1><p>本部分是关于 zig 一些额外知识的补充，暂时还没有决定好分类到何处！</p><h2 id="为什么-zig-可以做到比-c-更好的链接" tabindex="-1">为什么 zig 可以做到比 c 更好的链接 <a class="header-anchor" href="#为什么-zig-可以做到比-c-更好的链接" aria-label="Permalink to &quot;为什么 zig 可以做到比 c 更好的链接&quot;">​</a></h2><p>实际上，zig 本身实现了一个 C 的编译器，当然不仅仅如此，zig 还提供了一个比较 <strong><em>magic</em></strong> 的东西—— <a href="https://github.com/ziglang/glibc-abi-tool" target="_blank" rel="noreferrer"><code>glibc-abi-tool</code></a>，这是一个收集每个版本的 glibc 的 <code>.abilist</code> 文件的存储库，还包含一个将它们组合成一个数据集的工具。</p><p>所以，zig 本身所谓的 “<strong><em>ships with libc</em></strong>” 并不准确，它的确分发 libc，但它只携带每个版本的符号库，仅依赖这个符号库，zig 就可以实现在没有 libc 的情况下仍然正确地进行动态链接！</p><div class="info custom-block"><p class="custom-block-title">🅿️ 提示</p><p>由于这种特性，这导致 zig 尽管携带了 40 个 libc，却仍然能保持 45MB（linux-x86-64）左右的大小，作为对比 llvm 分发的 clang 完整的工具链的大小多达好几百 M。</p><p>关于更多的细节，你可以参考以下链接：</p><ul><li><a href="https://github.com/ziglang/zig/blob/0.4.0/libc/process_headers.zig" target="_blank" rel="noreferrer">process_headers tool</a></li><li><a href="https://github.com/ziglang/zig/wiki/Updating-libc" target="_blank" rel="noreferrer">Updating libc</a></li><li><a href="https://news.ycombinator.com/item?id=29538264" target="_blank" rel="noreferrer">hacker news</a></li></ul></div><h2 id="zig-能静态链接-libc-吗" tabindex="-1">zig 能静态链接 libc 吗？ <a class="header-anchor" href="#zig-能静态链接-libc-吗" aria-label="Permalink to &quot;zig 能静态链接 libc 吗？&quot;">​</a></h2><p>能，又不能！</p><p>zig 支持静态链接 musl（针对linux的另一个 libc，目标为嵌入式系统与移动设备），其他仅支持动态链接。受益于这种特性，我们可以将它作为 C 编译器的替代品使用，它可以提供更加完善的工具链。</p><p>举个比较<em>剑走偏锋</em>的例子，go 的 cgo 特性一直为人们所吐槽，一旦使用了它，基本就要和 go 宣称的非常方便的交叉编译说拜拜了，但我们可以使用 zig 来帮助我们实现 cgo 的交叉编译：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CC</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zig cc -target x86_64-linux-gnu&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CXX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zig cc -target x86_64-linux-gnu&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> go</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span></span></code></pre></div><p>设置 zig 作为 C 编译器来供 go 使用，只要对 zig 和 go 设置正确的target，就可以在本机实现完善的交叉编译。</p><p>再进一步，我们还可以构建出 linux 的使用 cgo 的静态链接的二进制可执行文件：</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">CC</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zig cc -target x86_64-linux-musl&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CXX</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;zig cc -target x86_64-linux-musl&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> CGO_CFLAGS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-D_LARGEFILE64_SOURCE&#39;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> go</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> build</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -ldflags=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;-linkmode=external -extldflags -static&#39;</span></span></code></pre></div><p>上方的 <code>CGO_CFLAGS</code> 是为了防止编译失败，<code>ldfalgs</code> 是为了指定静态链接！</p>',15),n=[l];function h(p,r,o,c,g,d){return s(),a("div",null,n)}const b=i(t,[["render",h]]);export{u as __pageData,b as default};
