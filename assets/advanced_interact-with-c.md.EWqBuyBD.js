import{_ as i,o as s,c as a,R as e}from"./chunks/framework.ekaVIUcx.js";const E=JSON.parse('{"title":"与 C 交互","description":"","frontmatter":{"outline":"deep"},"headers":[],"relativePath":"advanced/interact-with-c.md","filePath":"advanced/interact-with-c.md","lastUpdated":1701686389000}'),t={name:"advanced/interact-with-c.md"},n=e(`<h1 id="与-c-交互" tabindex="-1">与 C 交互 <a class="header-anchor" href="#与-c-交互" aria-label="Permalink to &quot;与 C 交互&quot;">​</a></h1><p>zig 作为一个可以独立于的语言，并且不依赖于 libc，但 zig 仍然具有非常强大的与 c 直接交互的能力，并远超其他语言。</p><div class="info custom-block"><p class="custom-block-title">🅿️ 提示</p><p>zig 所指的交互并不仅仅是使用 C 的库，zig 还可以作为 C 的编译器，导出 C ABI 兼容的库供其他程序使用。</p><p>并且 zig 使用 C 并不是通过 <a href="https://en.wikipedia.org/wiki/Foreign_function_interface" target="_blank" rel="noreferrer">FFI</a>/bindings 实现，而是近乎原生的调用，这归功于 zig 实现了一套 C 的编译器并且支持将 C 代码翻译为 zig 代码！</p></div><h2 id="c-abi-类型" tabindex="-1">C ABI 类型 <a class="header-anchor" href="#c-abi-类型" aria-label="Permalink to &quot;C ABI 类型&quot;">​</a></h2><p>zig 定义了几个对应 C ABI 的基本类型：</p><ul><li><code>c_char</code></li><li><code>c_short</code></li><li><code>c_ushort</code></li><li><code>c_int</code></li><li><code>c_uint</code></li><li><code>c_long</code></li><li><code>c_ulong</code></li><li><code>c_longlong</code></li><li><code>c_ulonglong</code></li><li><code>c_longdouble</code></li></ul><p>对应 C <code>void</code> 类型的时候，使用 <code>anyopaque</code> (大小为止的类型)。</p><h2 id="导入-c-header" tabindex="-1">导入 C Header <a class="header-anchor" href="#导入-c-header" aria-label="Permalink to &quot;导入 C Header&quot;">​</a></h2><p>C 语言共享类型通常是通过引入头文件实现，这点在 zig 中可以无缝做到，得益于 zig 的 <strong>translate-c</strong> 功能。</p><p>接下来展示一个例子，简单地引入 c 标准库的 <code>printf</code> 函数：</p><div class="language-zig vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">zig</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;"> c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">@cImport</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @cDefine</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;_NO_CRT_STDIO_INLINE&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    @cInclude</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;stdio.h&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">pub</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> fn</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> main</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    _</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> = </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">c</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">printf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;hello</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><div class="info custom-block"><p class="custom-block-title">🅿️ 提示</p><p>注意：为了构建这个，我们需要引入 <code>libc</code>，可以在 <code>build.zig</code> 中添加 <code>exe.linkLibC</code> 函数，<code>exe</code> 是默认的构建变量。</p><p>或者我们可以手动执行构建：<code>zig build-exe source.zig -lc</code></p></div><p><a href="https://ziglang.org/documentation/master/#cImport" target="_blank" rel="noreferrer"><code>@cImport</code></a> 函数接受一个表达式作为参数，该表达式会在编译期执行，用于控制预处理器指令并引入头文件。</p><div class="info custom-block"><p class="custom-block-title">🅿️ 提示</p><p>表达式内应仅包含 <a href="https://ziglang.org/documentation/master/#cInclude" target="_blank" rel="noreferrer"><code>@cInclude</code></a>、<a href="https://ziglang.org/documentation/master/#cDefine" target="_blank" rel="noreferrer"><code>@cDefine</code></a>、<a href="https://ziglang.org/documentation/master/#cUndef" target="_blank" rel="noreferrer"><code>@cUndef</code></a>，它们会在编译时进行解析并转换为 C 代码。</p><p>通常情况下，应当只存在一个 <code>@cImport</code>，这是防止编译器重复调用 clang，并且避免内联函数被重复，只有为了避免符号冲突（两个文件均定义了相同的标识符）和分析具有不同预处理定义的代码时才出现多个 <code>@cImport</code>。</p></div><h2 id="c-translation-cli" tabindex="-1"><code>C Translation CLI</code> <a class="header-anchor" href="#c-translation-cli" aria-label="Permalink to &quot;\`C Translation CLI\`&quot;">​</a></h2><p>TODO</p>`,16),l=[n];function c(o,h,d,p,r,k){return s(),a("div",null,l)}const u=i(t,[["render",c]]);export{E as __pageData,u as default};
